(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[888],{9316:function(e,t,n){"use strict";function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}n.r(t),n.d(t,{default:function(){return Sa}});var r=n(5893),a=(n(2702),n(3935)),i=n(7294);var s=function(e){return!!e&&"function"===typeof e.then};var u=function(e,t){if(null!=e)return e;throw new Error(null!==t&&void 0!==t?t:"Got unexpected null or undefined")};class c{}const l=new c,d={valueMaybe(){},valueOrThrow(){throw new Error(`Loadable expected value, but in "${this.state}" state`)},errorMaybe(){},errorOrThrow(){throw new Error(`Loadable expected error, but in "${this.state}" state`)},promiseMaybe(){},promiseOrThrow(){throw new Error(`Loadable expected promise, but in "${this.state}" state`)},is(e){return e.state===this.state&&e.contents===this.contents},map(e){if("hasError"===this.state)return this;if("hasValue"===this.state)try{const t=e(this.contents);return s(t)?p(t):f(t)}catch(t){return s(t)?p(t.next((()=>e(this.contents)))):h(t)}if("loading"===this.state)return p(this.contents.then(e).catch((t=>{if(s(t))return t.then((()=>e(this.contents)));throw t})));throw new Error("Invalid Loadable state")}};function f(e){return Object.freeze({state:"hasValue",contents:e,...d,getValue(){return this.contents},toPromise(){return Promise.resolve(this.contents)},valueMaybe(){return this.contents},valueOrThrow(){return this.contents}})}function h(e){return Object.freeze({state:"hasError",contents:e,...d,getValue(){throw this.contents},toPromise(){return Promise.reject(this.contents)},errorMaybe(){return this.contents},errorOrThrow(){return this.contents}})}function p(e){return Object.freeze({state:"loading",contents:e,...d,getValue(){throw this.contents.then((({__value:e})=>e))},toPromise(){return this.contents.then((({__value:e})=>e))},promiseMaybe(){return this.contents.then((({__value:e})=>e))},promiseOrThrow(){return this.contents.then((({__value:e})=>e))}})}var v={loadableWithValue:f,loadableWithError:h,loadableWithPromise:p,loadableLoading:function(){return p(new Promise((()=>{})))},loadableAll:function(e){return e.every((e=>"hasValue"===e.state))?f(e.map((e=>e.contents))):e.some((e=>"hasError"===e.state))?h(u(e.find((e=>"hasError"===e.state)),"Invalid loadable passed to loadableAll").contents):p(Promise.all(e.map((e=>e.contents))).then((e=>({__value:e}))))},Canceled:c,CANCELED:l};var y=function(e,t,{error:n}={}){return null};var m={setByAddingToSet:function(e,t){const n=new Set(e);return n.add(t),n},setByDeletingFromSet:function(e,t){const n=new Set(e);return n.delete(t),n},mapBySettingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n),o},mapByUpdatingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o},mapByDeletingFromMap:function(e,t){const n=new Map(e);return n.delete(t),n},mapByDeletingMultipleFromMap:function(e,t){const n=new Map(e);return t.forEach((e=>n.delete(e))),n}};var _=function*(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)};const g=(new Map).set("recoil_hamt_2020",!0).set("recoil_memory_managament_2020",!0);function S(e){var t;return null!==(t=g.get(e))&&void 0!==t&&t}S.setPass=e=>{g.set(e,!0)},S.setFail=e=>{g.set(e,!1)};var w=S;var b=function(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()};var T=function(e,...t){0};function R(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class A{constructor(e){R(this,"key",void 0),this.key=e}}class E extends A{}class N extends A{}var k={AbstractRecoilValue:A,RecoilState:E,RecoilValueReadOnly:N,isRecoilValue:function(e){return e instanceof E||e instanceof N}},V=k.AbstractRecoilValue,L=k.RecoilState,M=k.RecoilValueReadOnly,C=k.isRecoilValue,D=Object.freeze({__proto__:null,AbstractRecoilValue:V,RecoilState:L,RecoilValueReadOnly:M,isRecoilValue:C});class B{}const U=new B;class O extends Error{constructor(e){super(`Tried to set the value of Recoil selector ${e} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}const x=new Map,I=new Map;class P extends Error{}const z=new Map;function F(e){return z.get(e)}var j={nodes:x,recoilValues:I,registerNode:function(e){if(x.has(e.key)){const t=`Duplicate atom key "${e.key}". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;console.warn(t)}x.set(e.key,e);const t=null==e.set?new D.RecoilValueReadOnly(e.key):new D.RecoilState(e.key);return I.set(e.key,t),t},getNode:function(e){const t=x.get(e);if(null==t)throw new P(`Missing definition for RecoilValue: "${e}""`);return t},getNodeMaybe:function(e){return x.get(e)},deleteNodeConfigIfPossible:function(e){var t;if(!w("recoil_memory_managament_2020"))return;const n=x.get(e);var o;(null===n||void 0===n||null===(t=n.shouldDeleteConfigOnRelease)||void 0===t?void 0:t.call(n))&&(x.delete(e),null===(o=F(e))||void 0===o||o(),z.delete(e))},setConfigDeletionHandler:function(e,t){w("recoil_memory_managament_2020")&&(void 0===t?z.delete(e):z.set(e,t))},getConfigDeletionHandler:F,recoilValuesForKeys:function(e){return b(e,(e=>u(I.get(e))))},NodeMissingError:P,DefaultValue:B,DEFAULT_VALUE:U,RecoilValueNotReady:O};class ${}var q={RetentionZone:$,retentionZone:function(){return new $}};const{setByAddingToSet:G}=m,{getNode:W,getNodeMaybe:H,recoilValuesForKeys:K}=j,{RetentionZone:Z}=q,J=Object.freeze(new Set);class X extends Error{}function Q(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=W(n),i=function(e,t,n){if(!w("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(e){let n=o.get(e);n||o.set(e,n=new Set),n.add(t)}if(n instanceof Z)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!w("recoil_memory_managament_2020"))return;const o=e.getState().retention.nodesRetainedByZone;function r(e){const n=o.get(e);n&&n.delete(t),n&&0===n.size&&o.delete(e)}if(n instanceof Z)r(n);else if(Array.isArray(n))for(const e of n)r(e)}}(e,n,a.retainedBy),s=a.init(e,t,o);r.nodeCleanupFunctions.set(n,(()=>{s(),i()}))}function Y(e,t,n){return W(n).peek(e,t)}function ee(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let s=r.pop();s;s=r.pop()){var i;o.add(s);const e=null!==(i=a.nodeToNodeSubscriptions.get(s))&&void 0!==i?i:J;for(const t of e)o.has(t)||r.push(t)}return o}var te={getNodeLoadable:function(e,t,n){return Q(e,t,n,"get"),W(n).get(e,t)},peekNodeLoadable:Y,setNodeValue:function(e,t,n,o){const r=W(n);if(null==r.set)throw new X(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return Q(e,t,n,"set"),a(e,t,o)},cleanUpNode:function(e,t){var n;const o=e.getState();null===(n=o.nodeCleanupFunctions.get(t))||void 0===n||n(),o.nodeCleanupFunctions.delete(t)},setUnvalidatedAtomValue_DEPRECATED:function(e,t,n){var o;const r=H(t);return null===r||void 0===r||null===(o=r.invalidate)||void 0===o||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:G(e.dirtyAtoms,t)}},peekNodeInfo:function(e,t,n){var o,r,a;const i=e.getState(),s=e.getGraph(t.version),u=i.knownAtoms.has(n)?"atom":i.knownSelectors.has(n)?"selector":void 0,c=_(ee(e,t,new Set([n])),(e=>e!==n));return{loadable:Y(e,t,n),isActive:i.knownAtoms.has(n)||i.knownSelectors.has(n),isSet:"selector"!==u&&t.atomValues.has(n),isModified:t.dirtyAtoms.has(n),type:u,deps:K(null!==(o=s.nodeDeps.get(n))&&void 0!==o?o:[]),subscribers:{nodes:K(c),components:b(null!==(r=null===(a=i.nodeToComponentSubscriptions.get(n))||void 0===a?void 0:a.values())&&void 0!==r?r:[],(([e])=>({name:e})))}}},getDownstreamNodes:ee,initializeNodeIfNewToStore:Q};const{CANCELED:ne}=v,{getDownstreamNodes:oe,getNodeLoadable:re,setNodeValue:ae}=te,{getNodeMaybe:ie}=j,{DefaultValue:se,RecoilValueNotReady:ue}=j,{AbstractRecoilValue:ce,RecoilState:le,RecoilValueReadOnly:de,isRecoilValue:fe}=D;function he(e,t,n){if("set"===n.type){const{recoilValue:o,valueOrUpdater:r}=n,a=function(e,t,{key:n},o){if("function"===typeof o){const r=re(e,t,n);if("loading"===r.state)throw new ue(n);if("hasError"===r.state)throw r.contents;return o(r.contents)}return o}(e,t,o,r),i=ae(e,t,o.key,a);for(const[e,n]of i.entries())pe(t,e,n)}else if("setLoadable"===n.type){const{recoilValue:{key:e},loadable:o}=n;pe(t,e,o)}else if("markModified"===n.type){const{recoilValue:{key:e}}=n;t.dirtyAtoms.add(e)}else if("setUnvalidated"===n.type){var o;const{recoilValue:{key:e},unvalidatedValue:r}=n,a=ie(e);null===a||void 0===a||null===(o=a.invalidate)||void 0===o||o.call(a,t),t.atomValues.delete(e),t.nonvalidatedAtoms.set(e,r),t.dirtyAtoms.add(e)}else y(`Unknown action ${n.type}`)}function pe(e,t,n){"hasValue"===n.state&&n.contents instanceof se?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function ve(e,t){e.replaceState((n=>{const o=function(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}(n);for(const r of t)he(e,o,r);return _e(e,o),o}))}function ye(e,t){if(me.length){const n=me[me.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else ve(e,[t])}const me=[];function _e(e,t){const n=oe(e,t,t.dirtyAtoms);for(const a of n){var o,r;null===(o=ie(a))||void 0===o||null===(r=o.invalidate)||void 0===r||r.call(o,t)}}function ge(e,t,n){ye(e,{type:"set",recoilValue:t,valueOrUpdater:n})}let Se=0;var we={RecoilValueReadOnly:de,AbstractRecoilValue:ce,RecoilState:le,getRecoilValueAsLoadable:function(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version!==a.currentTree.version&&n.version!==(null===(o=a.nextTree)||void 0===o?void 0:o.version)&&n.version!==(null===(r=a.previousTree)||void 0===r?void 0:r.version)&&y("Tried to read from a discarded tree");const i=re(e,n,t);return"loading"===i.state&&i.contents.catch((()=>ne)),i},setRecoilValue:ge,setRecoilValueLoadable:function(e,t,n){if(n instanceof se)return ge(e,t,n);ye(e,{type:"setLoadable",recoilValue:t,loadable:n})},markRecoilValueModified:function(e,t){ye(e,{type:"markModified",recoilValue:t})},setUnvalidatedRecoilValue:function(e,t,n){ye(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})},subscribeToRecoilValue:function(e,{key:t},n,o=null){const r=Se++,a=e.getState();return a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),u(a.nodeToComponentSubscriptions.get(t)).set(r,[null!==o&&void 0!==o?o:"<not captured>",n]),{release:()=>{const n=e.getState(),o=n.nodeToComponentSubscriptions.get(t);void 0!==o&&o.has(r)?(o.delete(r),0===o.size&&n.nodeToComponentSubscriptions.delete(t)):y(`Subscription missing at release time for atom ${t}. This is a bug in Recoil.`)}}},isRecoilValue:fe,applyAtomValueWrites:function(e,t){const n=e.clone();return t.forEach(((e,t)=>{"hasValue"===e.state&&e.contents instanceof se?n.delete(t):n.set(t,e)})),n},batchStart:function(){const e=new Map;return me.push(e),()=>{for(const[t,n]of e)ve(t,n);me.pop()!==e&&y("Incorrect order of batch popping")}},invalidateDownstreams_FOR_TESTING:_e};const{unstable_batchedUpdates:be}=a;var Te={unstable_batchedUpdates:be};const{unstable_batchedUpdates:Re}=Te;var Ae={unstable_batchedUpdates:Re};const{batchStart:Ee}=we,{unstable_batchedUpdates:Ne}=Ae;let ke=Ne;var Ve={getBatcher:()=>ke,setBatcher:e=>{ke=e},batchUpdates:e=>{ke((()=>{let t=()=>{};try{t=Ee(),e()}finally{t()}}))}};var Le={enqueueExecution:function(e,t){t()}};var Me=function(e,...t){const n=new Set;e:for(const o of e){for(const e of t)if(e.has(o))continue e;n.add(o)}return n};var Ce=function(e,t){const n=new Map;return e.forEach(((e,o)=>{n.set(o,t(e,o))})),n};function De(e,t,n){const{nodeDeps:o,nodeToNodeSubscriptions:r}=t;e.forEach(((e,t)=>{const a=o.get(t);if(a&&n&&a!==n.nodeDeps.get(t))return;o.set(t,new Set(e));if((null==a?e:Me(e,a)).forEach((e=>{r.has(e)||r.set(e,new Set);u(r.get(e)).add(t)})),a){Me(a,e).forEach((e=>{if(!r.has(e))return;const n=u(r.get(e));n.delete(t),0===n.size&&r.delete(e)}))}}))}var Be={addToDependencyMap:function(e,t,n){n.has(e)||n.set(e,new Set),u(n.get(e)).add(t)},cloneGraph:function(e){return{nodeDeps:Ce(e.nodeDeps,(e=>new Set(e))),nodeToNodeSubscriptions:Ce(e.nodeToNodeSubscriptions,(e=>new Set(e)))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},mergeDepsIntoDependencyMap:function(e,t){e.forEach(((e,n)=>{t.has(n)||t.set(n,new Set);const o=u(t.get(n));e.forEach((e=>o.add(e)))}))},saveDependencyMapToStore:function(e,t,n){var o,r,a,i;const s=t.getState();n!==s.currentTree.version&&n!==(null===(o=s.nextTree)||void 0===o?void 0:o.version)&&n!==(null===(r=s.previousTree)||void 0===r?void 0:r.version)&&y("Tried to save dependencies to a discarded tree");const u=t.getGraph(n);if(De(e,u),n===(null===(a=s.previousTree)||void 0===a?void 0:a.version)){De(e,t.getGraph(s.currentTree.version),u)}if(n===(null===(i=s.previousTree)||void 0===i?void 0:i.version)||n===s.currentTree.version){var c;const n=null===(c=s.nextTree)||void 0===c?void 0:c.version;if(void 0!==n){De(e,t.getGraph(n),u)}}}};var Ue,Oe=(function(e){var t="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n={},o=Math.pow(2,5),r=o-1,a=o/2,i=o/4,s={},u=function(e){return function(){return e}},c=n.hash=function(e){var n="undefined"===typeof e?"undefined":t(e);if("number"===n)return e;"string"!==n&&(e+="");for(var o=0,r=0,a=e.length;r<a;++r)o=(o<<5)-o+e.charCodeAt(r)|0;return o},l=function(e,t){return t>>>e&r},d=function(e){return 1<<e},f=function(e,t){return n=e&t-1,n=(n=(858993459&(n-=n>>1&1431655765))+(n>>2&858993459))+(n>>4)&252645135,127&(n+=n>>8)+(n>>16);var n},h=function(e,t,n,o){var r=o;if(!e){var a=o.length;r=new Array(a);for(var i=0;i<a;++i)r[i]=o[i]}return r[t]=n,r},p=function(e,t,n){var o=n.length-1,r=0,a=0,i=n;if(e)r=a=t;else for(i=new Array(o);r<t;)i[a++]=n[r++];for(++r;r<=o;)i[a++]=n[r++];return e&&(i.length=o),i},v={__hamt_isEmpty:!0},y=function(e){return e===v||e&&e.__hamt_isEmpty},m=function(e,t,n,o){return{type:1,edit:e,hash:t,key:n,value:o,_modify:T}},_=function(e,t,n){return{type:2,edit:e,hash:t,children:n,_modify:R}},g=function(e,t,n){return{type:3,edit:e,mask:t,children:n,_modify:A}},S=function(e,t,n){return{type:4,edit:e,size:t,children:n,_modify:E}},w=function e(t,n,o,r,a,i){if(o===a)return _(t,o,[i,r]);var s=l(n,o),u=l(n,a);return g(t,d(s)|d(u),s===u?[e(t,n+5,o,r,a,i)]:s<u?[r,i]:[i,r])},b=function(e,t){return e===t.edit},T=function(e,t,n,o,r,a,i){if(t(a,this.key)){var u=o(this.value);return u===this.value?this:u===s?(--i.value,v):b(e,this)?(this.value=u,this):m(e,r,a,u)}var c=o();return c===s?this:(++i.value,w(e,n,this.hash,this,r,m(e,r,a,c)))},R=function(e,t,n,o,r,a,i){if(r===this.hash){var u=function(e,t,n,o,r,a,i,u){for(var c=r.length,l=0;l<c;++l){var d=r[l];if(n(i,d.key)){var f=d.value,v=a(f);return v===f?r:v===s?(--u.value,p(e,l,r)):h(e,l,m(t,o,i,v),r)}}var y=a();return y===s?r:(++u.value,h(e,c,m(t,o,i,y),r))}(b(e,this),e,t,this.hash,this.children,o,a,i);return u===this.children?this:u.length>1?_(e,this.hash,u):u[0]}var c=o();return c===s?this:(++i.value,w(e,n,this.hash,this,r,m(e,r,a,c)))},A=function(e,t,n,o,r,i,s){var u=this.mask,c=this.children,m=l(n,r),_=d(m),w=f(u,_),T=u&_,R=T?c[w]:v,A=R._modify(e,t,n+5,o,r,i,s);if(R===A)return this;var E,N=b(e,this),k=u,V=void 0;if(T&&y(A)){if(!(k&=~_))return v;if(c.length<=2&&((E=c[1^w])===v||1===E.type||2===E.type))return c[1^w];V=p(N,w,c)}else if(T||y(A))V=h(N,w,A,c);else{if(c.length>=a)return function(e,t,n,o,r){for(var a=[],i=o,s=0,u=0;i;++u)1&i&&(a[u]=r[s++]),i>>>=1;return a[t]=n,S(e,s+1,a)}(e,m,A,u,c);k|=_,V=function(e,t,n,o){var r=o.length;if(e){for(var a=r;a>=t;)o[a--]=o[a];return o[t]=n,o}for(var i=0,s=0,u=new Array(r+1);i<t;)u[s++]=o[i++];for(u[t]=n;i<r;)u[++s]=o[i++];return u}(N,w,A,c)}return N?(this.mask=k,this.children=V,this):g(e,k,V)},E=function(e,t,n,o,r,a,s){var u=this.size,c=this.children,d=l(n,r),f=c[d],p=(f||v)._modify(e,t,n+5,o,r,a,s);if(f===p)return this;var m=b(e,this),_=void 0;if(y(f)&&!y(p))++u,_=h(m,d,p,c);else if(!y(f)&&y(p)){if(--u<=i)return function(e,t,n,o){for(var r=new Array(t-1),a=0,i=0,s=0,u=o.length;s<u;++s)if(s!==n){var c=o[s];c&&!y(c)&&(r[a++]=c,i|=1<<s)}return g(e,i,r)}(e,u,d,c);_=h(m,d,v,c)}else _=h(m,d,p,c);return m?(this.size=u,this.children=_,this):S(e,u,_)};function N(e,t,n,o,r){this._editable=e,this._edit=t,this._config=n,this._root=o,this._size=r}v._modify=function(e,t,n,o,r,a,i){var u=o();return u===s?v:(++i.value,m(e,r,a,u))},N.prototype.setTree=function(e,t){return this._editable?(this._root=e,this._size=t,this):e===this._root?this:new N(this._editable,this._edit,this._config,e,t)};var k=n.tryGetHash=function(e,t,n,o){for(var r=o._root,a=0,i=o._config.keyEq;;)switch(r.type){case 1:return i(n,r.key)?r.value:e;case 2:if(t===r.hash)for(var s=r.children,u=0,c=s.length;u<c;++u){var h=s[u];if(i(n,h.key))return h.value}return e;case 3:var p=l(a,t),v=d(p);if(r.mask&v){r=r.children[f(r.mask,v)],a+=5;break}return e;case 4:if(r=r.children[l(a,t)]){a+=5;break}return e;default:return e}};N.prototype.tryGetHash=function(e,t,n){return k(e,t,n,this)};var V=n.tryGet=function(e,t,n){return k(e,n._config.hash(t),t,n)};N.prototype.tryGet=function(e,t){return V(e,t,this)};var L=n.getHash=function(e,t,n){return k(void 0,e,t,n)};N.prototype.getHash=function(e,t){return L(e,t,this)},n.get=function(e,t){return k(void 0,t._config.hash(e),e,t)},N.prototype.get=function(e,t){return V(t,e,this)};var M=n.has=function(e,t,n){return k(s,e,t,n)!==s};N.prototype.hasHash=function(e,t){return M(e,t,this)};var C=n.has=function(e,t){return M(t._config.hash(e),e,t)};N.prototype.has=function(e){return C(e,this)};var D=function(e,t){return e===t};n.make=function(e){return new N(0,0,{keyEq:e&&e.keyEq||D,hash:e&&e.hash||c},v,0)},n.empty=n.make();var B=n.isEmpty=function(e){return e&&!!y(e._root)};N.prototype.isEmpty=function(){return B(this)};var U=n.modifyHash=function(e,t,n,o){var r={value:o._size},a=o._root._modify(o._editable?o._edit:NaN,o._config.keyEq,0,e,t,n,r);return o.setTree(a,r.value)};N.prototype.modifyHash=function(e,t,n){return U(n,e,t,this)};var O=n.modify=function(e,t,n){return U(e,n._config.hash(t),t,n)};N.prototype.modify=function(e,t){return O(t,e,this)};var x=n.setHash=function(e,t,n,o){return U(u(n),e,t,o)};N.prototype.setHash=function(e,t,n){return x(e,t,n,this)};var I=n.set=function(e,t,n){return x(n._config.hash(e),e,t,n)};N.prototype.set=function(e,t){return I(e,t,this)};var P=u(s),z=n.removeHash=function(e,t,n){return U(P,e,t,n)};N.prototype.removeHash=N.prototype.deleteHash=function(e,t){return z(e,t,this)};var F=n.remove=function(e,t){return z(t._config.hash(e),e,t)};N.prototype.remove=N.prototype.delete=function(e){return F(e,this)};var j=n.beginMutation=function(e){return new N(e._editable+1,e._edit+1,e._config,e._root,e._size)};N.prototype.beginMutation=function(){return j(this)};var $=n.endMutation=function(e){return e._editable=e._editable&&e._editable-1,e};N.prototype.endMutation=function(){return $(this)};var q=n.mutate=function(e,t){var n=j(t);return e(n),$(n)};N.prototype.mutate=function(e){return q(e,this)};var G=function(e){return e&&W(e[0],e[1],e[2],e[3],e[4])},W=function(e,t,n,o,r){for(;n<e;){var a=t[n++];if(a&&!y(a))return H(a,o,[e,t,n,o,r])}return G(r)},H=function(e,t,n){switch(e.type){case 1:return{value:t(e),rest:n};case 2:case 4:case 3:var o=e.children;return W(o.length,o,0,t,n);default:return G(n)}},K={done:!0};function Z(e){this.v=e}Z.prototype.next=function(){if(!this.v)return K;var e=this.v;return this.v=G(e.rest),e},Z.prototype[Symbol.iterator]=function(){return this};var J=function(e,t){return new Z(H(e._root,t))},X=function(e){return[e.key,e.value]},Q=n.entries=function(e){return J(e,X)};N.prototype.entries=N.prototype[Symbol.iterator]=function(){return Q(this)};var Y=function(e){return e.key},ee=n.keys=function(e){return J(e,Y)};N.prototype.keys=function(){return ee(this)};var te=function(e){return e.value},ne=n.values=N.prototype.values=function(e){return J(e,te)};N.prototype.values=function(){return ne(this)};var oe=n.fold=function(e,t,n){var o=n._root;if(1===o.type)return e(t,o.value,o.key);for(var r=[o.children],a=void 0;a=r.pop();)for(var i=0,s=a.length;i<s;){var u=a[i++];u&&u.type&&(1===u.type?t=e(t,u.value,u.key):r.push(u.children))}return t};N.prototype.fold=function(e,t){return oe(e,t,this)};var re=n.forEach=function(e,t){return oe((function(n,o,r){return e(o,r,t)}),null,t)};N.prototype.forEach=function(e){return re(e,this)};var ae=n.count=function(e){return e._size};N.prototype.count=function(){return ae(this)},Object.defineProperty(N.prototype,"size",{get:N.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n}(Ue={exports:{}},Ue.exports),Ue.exports);class xe{constructor(e){R(this,"_map",void 0),this._map=new Map(null===e||void 0===e?void 0:e.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(e){return this._map.get(e)}has(e){return this._map.has(e)}set(e,t){return this._map.set(e,t),this}delete(e){return this._map.delete(e),this}clone(){return Pe(this)}toMap(){return new Map(this._map)}}class Ie{constructor(e){if(R(this,"_hamt",Oe.empty.beginMutation()),e instanceof Ie){const t=e._hamt.endMutation();e._hamt=t.beginMutation(),this._hamt=t.beginMutation()}else if(e)for(const[t,n]of e.entries())this._hamt.set(t,n)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(e){return this._hamt.get(e)}has(e){return this._hamt.has(e)}set(e,t){return this._hamt.set(e,t),this}delete(e){return this._hamt.delete(e),this}clone(){return Pe(this)}toMap(){return new Map(this._hamt)}}function Pe(e){return w("recoil_hamt_2020")?new Ie(e):new xe(e)}var ze=Pe,Fe=Object.freeze({__proto__:null,persistentMap:ze});const{graph:je}=Be,{persistentMap:$e}=Fe;let qe=0;const Ge=()=>qe++;function We(){const e=Ge();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:$e(),nonvalidatedAtoms:$e()}}var He={makeEmptyTreeState:We,makeEmptyStoreState:function(){const e=We();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(e.version,je()),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}},getNextTreeStateVersion:Ge};var Ke=function(...e){const t=new Set;for(const n of e)for(const e of n)t.add(e);return t};var Ze=function(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1};const{cleanUpNode:Je}=te,{deleteNodeConfigIfPossible:Xe,getNode:Qe}=j,{RetentionZone:Ye}=q,et=new Set;function tt(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return void y("releaseNodesNowOnCurrentTree should only be called at the end of a batch");const r=new Set;for(const i of t)if(i instanceof Ye)for(const e of ot(n,i))r.add(e);else r.add(i);const a=function(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,i=new Set;return s(t),a;function s(t){const c=new Set,l=function(e,t,n,o,r){const a=e.getGraph(t.version),i=[],s=new Set;for(;n.size>0;)c(u(n.values().next().value));return i;function c(e){if(o.has(e)||r.has(e))return void n.delete(e);if(s.has(e))return;const t=a.nodeToNodeSubscriptions.get(e);if(t)for(const n of t)c(n);s.add(e),n.delete(e),i.push(e)}}(e,o,t,a,i);for(const e of l){var d;if("recoilRoot"===Qe(e).retainedBy){i.add(e);continue}if((null!==(d=n.retention.referenceCounts.get(e))&&void 0!==d?d:0)>0){i.add(e);continue}if(rt(e).some((e=>n.retention.referenceCounts.get(e)))){i.add(e);continue}const t=r.nodeToNodeSubscriptions.get(e);t&&Ze(t,(e=>i.has(e)))?i.add(e):(a.add(e),c.add(e))}const f=new Set;for(const e of c)for(const t of null!==(h=r.nodeDeps.get(e))&&void 0!==h?h:et){var h;a.has(t)||f.add(t)}f.size&&s(f)}}(e,r);for(const i of a)nt(e,o,i)}function nt(e,t,n){if(!w("recoil_memory_managament_2020"))return;Je(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=rt(n);for(const u of r){var a;null===(a=o.retention.nodesRetainedByZone.get(u))||void 0===a||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const i=o.graphsByVersion.get(t.version);if(i){const e=i.nodeDeps.get(n);if(void 0!==e){i.nodeDeps.delete(n);for(const t of e){var s;null===(s=i.nodeToNodeSubscriptions.get(t))||void 0===s||s.delete(n)}}i.nodeToNodeSubscriptions.delete(n)}Xe(n)}function ot(e,t){var n;return null!==(n=e.retention.nodesRetainedByZone.get(t))&&void 0!==n?n:et}function rt(e){const t=Qe(e).retainedBy;return void 0===t||"components"===t||"recoilRoot"===t?[]:t instanceof Ye?[t]:t}function at(e,t){if(!w("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),function(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):tt(e,new Set([t]))}(e,t)}var it={updateRetainCount:function(e,t,n){var o;if(!w("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=(null!==(o=r.get(t))&&void 0!==o?o:0)+n;0===a?at(e,t):r.set(t,a)},updateRetainCountToZero:at,releaseScheduledRetainablesNow:function(e){if(!w("recoil_memory_managament_2020"))return;const t=e.getState();tt(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function(e){return void 0===e?"recoilRoot":e}};var st=function*(e){for(const t of e)for(const e of t)yield e};var ut={isSSR:"undefined"===typeof window,isReactNative:"undefined"!==typeof navigator&&"ReactNative"===navigator.product};const{isSSR:ct}=ut,{batchUpdates:lt}=Ve,{initializeNodeIfNewToStore:dt,peekNodeInfo:ft}=te,{graph:ht}=Be,{DEFAULT_VALUE:pt,recoilValues:vt,recoilValuesForKeys:yt}=j,{AbstractRecoilValue:mt,getRecoilValueAsLoadable:_t,setRecoilValue:gt,setUnvalidatedRecoilValue:St}=we,{updateRetainCount:wt,updateRetainCountToZero:bt}=it,{getNextTreeStateVersion:Tt,makeEmptyStoreState:Rt}=He;class At{constructor(e){R(this,"_store",void 0),R(this,"_refCount",0),R(this,"getLoadable",(e=>(this.checkRefCount_INTERNAL(),_t(this._store,e)))),R(this,"getPromise",(e=>(this.checkRefCount_INTERNAL(),this.getLoadable(e).toPromise()))),R(this,"getNodes_UNSTABLE",(e=>{if(this.checkRefCount_INTERNAL(),!0===(null===e||void 0===e?void 0:e.isModified)){if(!1===(null===e||void 0===e?void 0:e.isInitialized))return[];const t=this._store.getState().currentTree;return yt(t.dirtyAtoms)}const t=this._store.getState().knownAtoms,n=this._store.getState().knownSelectors;return null==(null===e||void 0===e?void 0:e.isInitialized)?vt.values():!0===e.isInitialized?yt(st([this._store.getState().knownAtoms,this._store.getState().knownSelectors])):_(vt.values(),(({key:e})=>!t.has(e)&&!n.has(e)))})),R(this,"getInfo_UNSTABLE",(({key:e})=>(this.checkRefCount_INTERNAL(),ft(this._store,this._store.getState().currentTree,e)))),R(this,"map",(e=>{this.checkRefCount_INTERNAL();const t=new kt(this);return e(t),Nt(t.getStore_INTERNAL())})),R(this,"asyncMap",(async e=>{this.checkRefCount_INTERNAL();const t=new kt(this);return await e(t),Nt(t.getStore_INTERNAL())})),this._store={getState:()=>e,replaceState:t=>{e.currentTree=t(e.currentTree)},getGraph:t=>{const n=e.graphsByVersion;if(n.has(t))return u(n.get(t));const o=ht();return n.set(t,o),o},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw new Error("Cannot subscribe to Snapshots")}};for(const t of this._store.getState().nodeCleanupFunctions.keys())dt(this._store,e.currentTree,t,"get"),wt(this._store,t,1);this.retain(),this.autorelease_INTERNAL()}retain(){if(!w("recoil_memory_managament_2020"))return()=>{};this._refCount++;let e=!1;return()=>{e||(e=!0,this.release_INTERNAL())}}autorelease_INTERNAL(){w("recoil_memory_managament_2020")&&(ct||window.setTimeout((()=>this.release_INTERNAL()),0))}release_INTERNAL(){w("recoil_memory_managament_2020")&&(this._refCount--,this._refCount)}checkRefCount_INTERNAL(){w("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this.getID_INTERNAL()}getID_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}}function Et(e,t,n=!1){const o=e.getState(),r=n?Tt():t.version;return{currentTree:n?{version:r,stateID:r,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()}:t,commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(r,e.getGraph(t.version)),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}function Nt(e,t="current"){const n=e.getState(),o="current"===t?n.currentTree:u(n.previousTree);return new At(Et(e,o))}class kt extends At{constructor(e){super(Et(e.getStore_INTERNAL(),e.getStore_INTERNAL().getState().currentTree,!0)),R(this,"set",((e,t)=>{this.checkRefCount_INTERNAL();const n=this.getStore_INTERNAL();lt((()=>{wt(n,e.key,1),gt(this.getStore_INTERNAL(),e,t)}))})),R(this,"reset",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();lt((()=>{wt(t,e.key,1),gt(this.getStore_INTERNAL(),e,pt)}))})),R(this,"setUnvalidatedAtomValues_DEPRECATED",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();lt((()=>{for(const[n,o]of e.entries())wt(t,n,1),St(t,new mt(n),o)}))}))}}var Vt={Snapshot:At,MutableSnapshot:kt,freshSnapshot:function(e){const t=new At(Rt());return null!=e?t.map(e):t},cloneSnapshot:Nt},Lt=Vt.Snapshot,Mt=Vt.MutableSnapshot,Ct=Vt.freshSnapshot,Dt=Vt.cloneSnapshot,Bt=Object.freeze({__proto__:null,Snapshot:Lt,MutableSnapshot:Mt,freshSnapshot:Ct,cloneSnapshot:Dt});const{getNextTreeStateVersion:Ut,makeEmptyStoreState:Ot}=He,{cleanUpNode:xt,getDownstreamNodes:It,setNodeValue:Pt,setUnvalidatedAtomValue_DEPRECATED:zt}=te,{graph:Ft}=Be,{cloneGraph:jt}=Be,{applyAtomValueWrites:$t}=we,{releaseScheduledRetainablesNow:qt}=it,{freshSnapshot:Gt}=Bt,{useCallback:Wt,useContext:Ht,useEffect:Kt,useMemo:Zt,useRef:Jt,useState:Xt}=i;function Qt(){throw new Error("This component must be used inside a <RecoilRoot> component.")}const Yt=Object.freeze({getState:Qt,replaceState:Qt,getGraph:Qt,subscribeToTransactions:Qt,addTransactionMetadata:Qt});let en=!1;function tn(e){if(en)throw new Error("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(null===t.nextTree){w("recoil_memory_managament_2020")&&w("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&qt(e);const n=t.currentTree.version,o=Ut();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,jt(u(t.graphsByVersion.get(n))))}}const nn=i.createContext({current:Yt}),on=()=>Ht(nn),rn=i.createContext(null);function an(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[n,a]of t.nodeTransactionSubscriptions)if(o.has(n))for(const[t,o]of a)o(e);for(const[n,o]of t.transactionSubscriptions)o(e);const r=It(e,n,o);for(const e of r){const o=t.nodeToComponentSubscriptions.get(e);if(o)for(const[e,[t,r]]of o)r(n)}t.suspendedComponentResolvers.forEach((e=>e()))}t.queuedComponentCallbacks_DEPRECATED.forEach((e=>e(n))),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function sn({setNotifyBatcherOfChange:e}){const t=on(),[n,o]=Xt([]);return e((()=>o({}))),Kt((()=>{Le.enqueueExecution("Batcher",(()=>{const e=t.current.getState();e.commitDepth++;try{const{nextTree:n}=e;if(null===n)return;e.previousTree=e.currentTree,e.currentTree=n,e.nextTree=null,an(t.current);const o=u(e.previousTree).version;e.graphsByVersion.delete(o),e.previousTree=null,w("recoil_memory_managament_2020")&&qt(t.current)}finally{e.commitDepth--}}))})),Kt((()=>()=>{e((()=>{}))}),[e]),null}let un=0;function cn({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){var r;let a;const s=Jt(null),c=Wt((e=>{s.current=e}),[s]),l=null!==(r=i.createMutableSource)&&void 0!==r?r:i.unstable_createMutableSource,d=null!==n&&void 0!==n?n:{getState:()=>a.current,replaceState:e=>{const t=f.current.getState();tn(f.current);const n=u(t.nextTree);let o;try{en=!0,o=e(n)}finally{en=!1}o!==n&&(t.nextTree=o,u(s.current)())},getGraph:e=>{const t=a.current.graphsByVersion;if(t.has(e))return u(t.get(e));const n=Ft();return t.set(e,n),n},subscribeToTransactions:(e,t)=>{if(null==t){const{transactionSubscriptions:t}=f.current.getState(),n=un++;return t.set(n,e),{release:()=>{t.delete(n)}}}{const{nodeTransactionSubscriptions:n}=f.current.getState();n.has(t)||n.set(t,new Map);const o=un++;return u(n.get(t)).set(o,e),{release:()=>{const e=n.get(t);e&&(e.delete(o),0===e.size&&n.delete(t))}}}},addTransactionMetadata:e=>{tn(f.current);for(const t of Object.keys(e))u(f.current.getState().nextTree).transactionMetadata[t]=e[t]}},f=Jt(d);a=Jt(null!=e?function(e,t){const n=Ot();return t({set:(t,o)=>{const r=n.currentTree,a=Pt(e,r,t.key,o),i=new Set(a.keys()),s=r.nonvalidatedAtoms.clone();for(const e of i)s.delete(e);n.currentTree={...r,dirtyAtoms:Ke(r.dirtyAtoms,i),atomValues:$t(r.atomValues,a),nonvalidatedAtoms:s}},setUnvalidatedAtomValues:e=>{e.forEach(((e,t)=>{n.currentTree=zt(n.currentTree,t,e)}))}}),n}(d,e):null!=t?function(e){return Gt().map(e).getStore_INTERNAL().getState()}(t):Ot());const h=Zt((()=>l?l(a,(()=>a.current.currentTree.version)):null),[l,a]);return Kt((()=>()=>{for(const e of f.current.getState().knownAtoms)xt(f.current,e)}),[]),i.createElement(nn.Provider,{value:f},i.createElement(rn.Provider,{value:h},i.createElement(sn,{setNotifyBatcherOfChange:c}),o))}var ln={useStoreRef:on,useRecoilMutableSource:function(){const e=Ht(rn);return null==e&&T("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),e},RecoilRoot:function(e){const{override:t,...n}=e,o=on();return!1===t&&o.current!==Yt?i.createElement(i.Fragment,null,e.children):i.createElement(cn,n)},sendEndOfBatchNotifications_FOR_TESTING:an};var dn=function(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n};var fn=function(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n};var hn=function(e,t){if(!e)throw new Error(t)};var pn,vn=function(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t};const yn=null!==(pn=i.useMutableSource)&&void 0!==pn?pn:i.unstable_useMutableSource;var mn={mutableSourceExists:function(){return yn&&!("undefined"!==typeof window&&window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE)},useMutableSource:yn};var _n=function(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0};const{useRef:gn}=i;var Sn=function(){return gn(),"<component name not available>"};const{batchUpdates:wn}=Ve,{DEFAULT_VALUE:bn,getNode:Tn,nodes:Rn}=j,{useRecoilMutableSource:An,useStoreRef:En}=ln,{isRecoilValue:Nn}=D,{AbstractRecoilValue:kn,getRecoilValueAsLoadable:Vn,setRecoilValue:Ln,setRecoilValueLoadable:Mn,setUnvalidatedRecoilValue:Cn,subscribeToRecoilValue:Dn}=we,{updateRetainCount:Bn}=it,{RetentionZone:Un}=q,{Snapshot:On,cloneSnapshot:xn}=Bt,{setByAddingToSet:In}=m,{isSSR:Pn}=ut,{mutableSourceExists:zn,useMutableSource:Fn}=mn,{useCallback:jn,useEffect:$n,useMemo:qn,useRef:Gn,useState:Wn}=i,Hn=12e4;function Kn(e,t,n){if("hasValue"===e.state)return e.contents;if("loading"===e.state){throw new Promise((e=>{n.current.getState().suspendedComponentResolvers.add(e)}))}throw"hasError"===e.state?e.contents:new Error(`Invalid value of loadable atom "${t.key}"`)}function Zn(e){return w("recoil_memory_managament_2020")&&ro(e),zn()?function(e){const t=En(),n=jn((()=>{const n=t.current,o=n.getState().currentTree;return Vn(n,e,o)}),[t,e]),o=jn((()=>n()),[n]),r=Sn(),a=jn(((o,a)=>{const i=t.current;return Dn(i,e,(()=>{if(!w("recoil_suppress_rerender_in_callback"))return a();const e=n();u.current.is(e)||a(),u.current=e}),r).release}),[t,e,r,n]),i=An(),s=Fn(i,o,a),u=Gn(s);return $n((()=>{u.current=s})),s}(e):function(e){const t=En(),[n,o]=Wn([]),r=Sn();$n((()=>{const n=t.current,a=n.getState(),s=Dn(n,e,(t=>{var r;if(!w("recoil_suppress_rerender_in_callback"))return o([]);const a=Vn(n,e,n.getState().currentTree);(null===(r=i.current)||void 0===r?void 0:r.is(a))||o(a),i.current=a}),r);if(a.nextTree)n.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{i.current=null,o([])}));else{var u;if(!w("recoil_suppress_rerender_in_callback"))return o([]);const t=Vn(n,e,n.getState().currentTree);(null===(u=i.current)||void 0===u?void 0:u.is(t))||o(t),i.current=t}return s.release}),[r,e,t]);const a=Vn(t.current,e),i=Gn(a);return $n((()=>{i.current=a})),a}(e)}function Jn(e){const t=En();return Kn(Zn(e),e,t)}function Xn(e){const t=En();return jn((n=>{Ln(t.current,e,n)}),[t,e])}function Qn(e){const t=En();$n((()=>t.current.subscribeToTransactions(e).release),[e,t])}function Yn(e){const t=e.atomValues.toMap(),n=Ce(dn(t,((e,t)=>{const n=Tn(t).persistence_UNSTABLE;return null!=n&&"none"!==n.type&&"hasValue"===e.state})),(e=>e.contents));return vn(e.nonvalidatedAtoms.toMap(),n)}function eo(e){const t=Gn();return $n((()=>{t.current=e})),t.current}function to(){const e=En();return jn((t=>{var n;const o=e.current.getState(),r=null!==(n=o.nextTree)&&void 0!==n?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;wn((()=>{const n=new Set;for(const e of[r.atomValues.keys(),a.atomValues.keys()])for(const t of e){var o,i;(null===(o=r.atomValues.get(t))||void 0===o?void 0:o.contents)!==(null===(i=a.atomValues.get(t))||void 0===i?void 0:i.contents)&&Tn(t).shouldRestoreFromSnapshots&&n.add(t)}n.forEach((t=>{Mn(e.current,new kn(t),a.atomValues.has(t)?u(a.atomValues.get(t)):bn)})),e.current.replaceState((e=>({...e,stateID:t.getID_INTERNAL()})))}))}),[e])}class no{}const oo=new no;function ro(e){if(w("recoil_memory_managament_2020"))return function(e){const t=(Array.isArray(e)?e:[e]).map((e=>e instanceof Un?e:e.key)),n=En();$n((()=>{if(!w("recoil_memory_managament_2020"))return;const e=n.current;if(o.current&&!Pn)window.clearTimeout(o.current),o.current=null;else{y("Did not retain recoil value on render, or committed after timeout elapsed. This is fine, but odd.");for(const n of t)Bn(e,n,1)}return()=>{for(const n of t)Bn(e,n,-1)}}),[n,...t]);const o=Gn(),r=eo(t);if(!Pn&&(void 0===r||!_n(r,t))){const e=n.current;for(const n of t)Bn(e,n,1);if(r)for(const t of r)Bn(e,t,-1);o.current&&window.clearTimeout(o.current),o.current=window.setTimeout((()=>{o.current=null;for(const n of t)Bn(e,n,-1)}),Hn)}}(e)}var ao={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useGotoRecoilSnapshot:to,useRecoilCallback:function(e,t){const n=En(),o=to();return jn(((...t)=>{function r(e,t){Ln(n.current,e,t)}function a(e){Ln(n.current,e,bn)}const i=xn(n.current);let s=oo;return wn((()=>{const n="useRecoilCallback expects a function that returns a function: it accepts a function of the type (RecoilInterface) => T = R and returns a callback function T => R, where RecoilInterface is an object {snapshot, set, ...} and T and R are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!==typeof e)throw new Error(n);const u=e({set:r,reset:a,snapshot:i,gotoSnapshot:o});if("function"!==typeof u)throw new Error(n);s=u(...t)})),s instanceof no&&hn(!1),s}),null!=t?[...t,n]:void 0)},useRecoilInterface:function(){const e=En(),[t,n]=Wn([]),o=Gn(new Set);o.current=new Set;const r=Gn(new Set),a=Gn(new Map),i=jn((e=>{const t=a.current.get(e);t&&(t.release(),a.current.delete(e))}),[a]),s=Sn();return $n((()=>{const t=e.current;function u(e,t){a.current.has(t)&&n([])}Me(o.current,r.current).forEach((e=>{if(a.current.has(e))return void T(`Double subscription to RecoilValue "${e}"`);const n=Dn(t,new kn(e),(t=>{u(0,e)}),s);a.current.set(e,n);t.getState().nextTree?t.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{u(t.getState(),e)})):u(t.getState(),e)})),Me(r.current,o.current).forEach((e=>{i(e)})),r.current=o.current})),$n((()=>{const e=a.current;return()=>e.forEach(((e,t)=>i(t)))}),[i]),qn((()=>{function t(t){return n=>{Ln(e.current,t,n)}}function n(t){return o.current.has(t.key)||(o.current=In(o.current,t.key)),Vn(e.current,t)}function r(t){return Kn(n(t),t,e)}return{getRecoilValue:r,getRecoilValueLoadable:n,getRecoilState:function(e){return[r(e),t(e)]},getRecoilStateLoadable:function(e){return[n(e),t(e)]},getSetRecoilState:t,getResetRecoilState:function(t){return()=>Ln(e.current,t,bn)}}}),[o,e])},useRecoilSnapshot:function(){const e=En(),[t,n]=Wn((()=>xn(e.current))),o=eo(t),r=Gn();return $n((()=>(r.current&&!Pn&&window.clearTimeout(r.current),t.retain())),[t]),Qn(jn((e=>n(xn(e))),[])),o===t||Pn||(r.current&&(null===o||void 0===o||o.release_INTERNAL(),window.clearTimeout(r.current)),t.retain(),r.current=window.setTimeout((()=>{t.release_INTERNAL(),r.current=null}),Hn)),t},useRecoilState:function(e){return[Jn(e),Xn(e)]},useRecoilStateLoadable:function(e){return[Zn(e),Xn(e)]},useRecoilTransactionObserver:function(e){Qn(jn((t=>{const n=xn(t,"current"),o=xn(t,"previous");e({snapshot:n,previousSnapshot:o})}),[e]))},useRecoilValue:Jn,useRecoilValueLoadable:Zn,useRetain:ro,useResetRecoilState:function(e){const t=En();return jn((()=>{Ln(t.current,e,bn)}),[t,e])},useSetRecoilState:Xn,useSetUnvalidatedAtomValues:function(){const e=En();return(t,n={})=>{wn((()=>{e.current.addTransactionMetadata(n),t.forEach(((t,n)=>Cn(e.current,new kn(n),t)))}))}},useTransactionObservation_DEPRECATED:function(e){Qn(jn((t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(y("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),n=t.getState().currentTree);const r=Yn(o),a=Yn(n),i=Ce(Rn,(e=>{var t,n,o,r;return{persistence_UNSTABLE:{type:null!==(t=null===(n=e.persistence_UNSTABLE)||void 0===n?void 0:n.type)&&void 0!==t?t:"none",backButton:null!==(o=null===(r=e.persistence_UNSTABLE)||void 0===r?void 0:r.backButton)&&void 0!==o&&o}}})),s=fn(o.dirtyAtoms,(e=>r.has(e)||a.has(e)));e({atomValues:r,previousAtomValues:a,atomInfo:i,modifiedAtoms:s,transactionMetadata:{...o.transactionMetadata}})}),[e]))},useTransactionSubscription_DEPRECATED:Qn};const{peekNodeInfo:io}=te,{useStoreRef:so}=ln;var uo=function(){const e=so();return({key:t})=>io(e.current,e.current.getState().currentTree,t)};const{RecoilRoot:co,useStoreRef:lo}=ln,{useMemo:fo}=i;var ho=function(){const e=lo().current;return fo((()=>function({children:t}){return i.createElement(co,{store_INTERNAL:e},t)}),[e])};const{isReactNative:po,isSSR:vo}=ut;function yo(e,t,n){if("string"===typeof e&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if(!0!==(null===t||void 0===t?void 0:t.allowFunctions))throw new Error("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(null===e)return"null";var o;if("object"!==typeof e)return null!==(o=JSON.stringify(e))&&void 0!==o?o:"";if(s(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map(((e,n)=>yo(e,t,n.toString())))}]`;if("function"===typeof e.toJSON)return yo(e.toJSON(n),t,n);if(e instanceof Map){const o={};for(const[n,r]of e)o["string"===typeof n?n:yo(n,t)]=r;return yo(o,t,n)}return e instanceof Set?yo(Array.from(e).sort(((e,n)=>yo(e,t).localeCompare(yo(n,t)))),t,n):void 0!==Symbol&&null!=e[Symbol.iterator]&&"function"===typeof e[Symbol.iterator]?yo(Array.from(e),t,n):`{${Object.keys(e).filter((t=>void 0!==e[t])).sort().map((n=>`${yo(n,t)}:${yo(e[n],t,n)}`)).join(",")}}`}var mo=function(e,t={allowFunctions:!1}){return yo(e,t)};const _o=(e,t,n)=>{var o;if(null==e)return;if(null===n||void 0===n||null===(o=n.onNodeVisit)||void 0===o||o.call(n,e),"leaf"===e.type)return e;const r=t(e.nodeKey);return _o(e.branches.get(r),t,n)},go=(e,t,n,o,r,a)=>{var i;let s;if(null==e)if(0===t.length)s={type:"leaf",value:o,parent:n,branchKey:r};else{const[e,...i]=t,[u,c]=e;s={type:"branch",nodeKey:u,parent:n,branches:new Map,branchKey:r},s.branches.set(c,go(null,i,s,o,c,a))}else if(s=e,t.length){const[n,...r]=t,[i,s]=n;("branch"!==e.type||e.nodeKey!==i)&&hn(!1),e.branches.set(s,go(e.branches.get(s),r,e,o,s,a))}return null===a||void 0===a||null===(i=a.onNodeVisit)||void 0===i||i.call(a,s),s},So=(e,t,n)=>n?(n.branches.delete(t.branchKey),wo(e,n,n.parent)):e===t,wo=(e,t,n)=>n?(0===t.branches.size&&n.branches.delete(t.branchKey),wo(e,n,n.parent)):e===t,bo=e=>"leaf"===e.type?1:Array.from(e.branches.values()).reduce(((e,t)=>e+bo(t)),0);var To=class{constructor(e){var t,n,o;R(this,"_numLeafs",void 0),R(this,"_root",void 0),R(this,"_onHit",void 0),R(this,"_onSet",void 0),R(this,"_mapNodeValue",void 0),this._numLeafs=0,this._root=null,this._onHit=null!==(t=null===e||void 0===e?void 0:e.onHit)&&void 0!==t?t:()=>{},this._onSet=null!==(n=null===e||void 0===e?void 0:e.onSet)&&void 0!==n?n:()=>{},this._mapNodeValue=null!==(o=null===e||void 0===e?void 0:e.mapNodeValue)&&void 0!==o?o:e=>e}size(){return this._numLeafs}root(){return this._root}get(e,t){var n;return null===(n=this.getLeafNode(e,t))||void 0===n?void 0:n.value}getLeafNode(e,t){return _o(this.root(),(t=>this._mapNodeValue(e(t))),{onNodeVisit:e=>{null===t||void 0===t||t.onNodeVisit(e),"leaf"===e.type&&this._onHit(e)}})}set(e,t,n){let o;const r=go(this.root(),e.map((([e,t])=>[e,this._mapNodeValue(t)])),null,t,null,{onNodeVisit:e=>{null===n||void 0===n||n.onNodeVisit(e),"leaf"===e.type&&(o=e)}});this.root()||(this._root=r),this._numLeafs++,this._onSet(u(o))}delete(e){if(!this.root())return!1;const t=u(this.root());return!!So(t,e,e.parent)&&(e===t||"branch"===t.type&&!t.branches.size?(this._root=null,this._numLeafs=0,!0):(this._numLeafs-=bo(e),!0))}clear(){this._numLeafs=0,this._root=null}},Ro=Object.freeze({__proto__:null,TreeCache:To});var Ao=class{constructor(e){var t;R(this,"_maxSize",void 0),R(this,"_size",void 0),R(this,"_head",void 0),R(this,"_tail",void 0),R(this,"_map",void 0),R(this,"_keyMapper",void 0),this._maxSize=e.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!==(t=e.mapKey)&&void 0!==t?t:e=>e}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(e){return this._map.has(this._keyMapper(e))}get(e){const t=this._keyMapper(e),n=this._map.get(t);if(n)return this.set(e,n.value),n.value}set(e,t){const n=this._keyMapper(e);this._map.get(n)&&this.delete(e);const o=this.head(),r={key:e,right:o,left:null,value:t};o?o.left=r:this._tail=r,this._map.set(n,r),this._head=r,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const e=this.tail();e&&this.delete(e.key)}delete(e){const t=this._keyMapper(e);if(!this._size||!this._map.has(t))return;const n=u(this._map.get(t)),o=n.right,r=n.left;o&&(o.left=n.left),r&&(r.right=n.right),n===this.head()&&(this._head=o),n===this.tail()&&(this._tail=r),this._map.delete(t),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}},Eo=Object.freeze({__proto__:null,LRUCache:Ao});const{LRUCache:No}=Eo,{TreeCache:ko}=Ro;var Vo=function(e,t=(e=>e)){const n=new No({maxSize:e}),o=new ko({mapNodeValue:t,onHit:e=>{n.set(e,!0)},onSet:t=>{const r=n.tail();n.set(t,!0),r&&o.size()>e&&o.delete(r.key)}});return o};const{TreeCache:Lo}=Ro,Mo={equality:"reference",eviction:"none",maxSize:1/0};var Co=function({equality:e=Mo.equality,eviction:t=Mo.eviction,maxSize:n=Mo.maxSize}=Mo){return function(e,t,n){switch(e){case"none":return new Lo({mapNodeValue:n});case"lru":return Vo(u(t),n)}throw new Error(`Unrecognized eviction policy ${e}`)}(t,n,function(e){switch(e){case"reference":return e=>e;case"value":return e=>mo(e)}throw new Error(`Unrecognized equality policy ${e}`)}(e))};var Do={startPerfBlock:function(e){return()=>null}};const{CANCELED:Bo,Canceled:Uo,loadableWithError:Oo,loadableWithPromise:xo,loadableWithValue:Io}=v,{getNodeLoadable:Po,peekNodeLoadable:zo,setNodeValue:Fo}=te,{saveDependencyMapToStore:jo}=Be,{DEFAULT_VALUE:$o,RecoilValueNotReady:qo,getConfigDeletionHandler:Go,registerNode:Wo}=j,{isRecoilValue:Ho}=D,{AbstractRecoilValue:Ko}=D,{setRecoilValueLoadable:Zo}=we,{retainedByOptionWithDefault:Jo}=it,{cloneSnapshot:Xo}=Bt,{startPerfBlock:Qo}=Do,Yo=[],er=new Map,tr=(()=>{let e=0;return()=>e++})();var nr=function(e){const{key:t,get:n,cachePolicy_UNSTABLE:o}=e,r=null!=e.set?e.set:void 0,a=Co(null!==o&&void 0!==o?o:{equality:"reference",eviction:"none"}),i=Jo(e.retainedBy_UNSTABLE),c=new Map;let l=0;function d(){return!w("recoil_memory_managament_2020")||l>0}function f(e){return c.has(e)||c.set(e,{depValuesDiscoveredSoFarDuringAsyncWork:null,latestLoadable:null,latestExecutionId:null,stateVersion:null}),u(c.get(e))}function h(e){return l++,e.getState().knownSelectors.add(t),()=>{l--,e.getState().knownSelectors.delete(t),c.delete(e)}}function p(){return void 0!==Go(t)&&!d()}function v(e,t,n){if("loading"===t.state){let t=er.get(n);null==t&&er.set(n,t=new Set),t.add(e)}}function m(e,t,n){if(t.atomValues.has(n))return u(t.atomValues.get(n));const o=Po(e,t,n),r=e.getState().knownSelectors.has(n);return"loading"!==o.state&&r&&t.atomValues.set(n,o),o}function _(e,n,o,r,a){return n.then((n=>{if(!d())return V(e,a),Bo;if(n instanceof Uo)return y("Selector was released while it had dependencies"),Bo;const{__key:r,__value:i}=null!==n&&void 0!==n?n:{};let s=!0;null!=r&&(o.atomValues.set(r,Io(i)),s=!1);const[u,c]=b(e,o,a,s);if(L(e,a)&&k(c,e,a),M(u),"loading"!==u.state&&(D(o,T(c),u),S(e,o,new Set(c.keys()),a),g(e,u,a)),"hasError"===u.state)throw u.contents;return"hasValue"===u.state?{__value:u.contents,__key:t}:u.contents})).catch((t=>{if(!d())return V(e,a),Bo;const n=Oo(t);throw C(t),D(o,T(r),Oo(t)),S(e,o,new Set(r.keys()),a),g(e,n,a),t}))}function g(e,n,o){L(e,o)&&(N(n,e),function(e,n){const o=er.get(n);if(void 0!==o){for(const n of o)Zo(n,new Ko(t),e);er.delete(n)}}(n,o))}function S(e,n,o,r){var a,i,s,u,c,l,d;(L(e,r)||n.version===(null===(a=e.getState())||void 0===a||null===(i=a.currentTree)||void 0===i?void 0:i.version)||n.version===(null===(s=e.getState())||void 0===s||null===(u=s.nextTree)||void 0===u?void 0:u.version))&&jo(new Map([[t,o]]),e,null!==(c=null===(l=e.getState())||void 0===l||null===(d=l.nextTree)||void 0===d?void 0:d.version)&&void 0!==c?c:e.getState().currentTree.version)}function b(e,o,r,a=!1){const i=Qo(t);let u,c,l=!1;const f=new Map,h=new Set;function p(t){const{key:n}=t;!function(e,t,n,o,r){n.add(o),S(e,t,n,r)}(e,o,h,n,r);const i=a?Po(e,o,n):m(e,o,n);if(M(i),f.set(n,i),"hasValue"===i.state)return i.contents;throw i.contents}S(e,o,h,r);let v=!1;const y=t=>(...n)=>{if(!v)throw new Error("getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can obtain the current Recoil state without a subscription.");const o=Xo(e),r=t({snapshot:o});if("function"!==typeof r)throw new Error("getCallback() expects a function that returns a function.");return r(...n)};try{u=n({get:p,getCallback:y}),u=Ho(u)?p(u):u,v=!0,s(u)?u=function(e,n,o,r,a){return n.then((n=>{if(!d())return V(e,a),Bo;const i=Io(n);return C(n),D(o,T(r),i),S(e,o,new Set(r.keys()),a),g(e,i,a),{__value:n,__key:t}})).catch((t=>{if(!d())return V(e,a),Bo;if(L(e,a)&&k(r,e,a),s(t))return _(e,t,o,r,a);const n=Oo(t);throw C(t),D(o,T(r),n),S(e,o,new Set(r.keys()),a),g(e,n,a),t}))}(e,u,o,f,r).finally(i):i()}catch(w){u=w,s(u)?u=_(e,u,o,f,r).finally(i):(l=!0,i())}return c=l?Oo(u):s(u)?xo(u):Io(u),M(c),[c,f]}function T(e){return Array.from(e.entries()).map((([e,t])=>[e,t.contents]))}function R(e,t){const n=tr(),[o,r]=b(e,t,n);return N(o,e,r,n,t),function(e,t,n){"loading"!==n.state&&D(e,t,n)}(t,T(r),o),v(e,o,n),o}function A(e,n){const o=function(e,n){const o=new Set,r=f(e),i=a.get((t=>("string"!==typeof t&&hn(!1),m(e,n,t).contents)),{onNodeVisit:e=>{"branch"===e.type&&e.nodeKey!==t&&"string"===typeof e.nodeKey&&o.add(e.nodeKey)}});return i&&S(e,n,o,r.latestExecutionId),i}(e,n);if(null!=o)return N(o,e),o;const r=function(e,t){var n;const[,o]=null!==(n=Array.from(c.entries()).find((([,n])=>null!=n.latestLoadable&&null!=n.latestExecutionId&&!function(e,t){var n,o;const r=f(e),a=null!==(n=r.depValuesDiscoveredSoFarDuringAsyncWork)&&void 0!==n?n:new Map,i=Array((null!==(o=E.get(t.version))&&void 0!==o?o:new Map).entries()),s=E.has(t.version)&&i.length===a.size&&i.every((([e,t])=>a.get(e)===t));if(null==a||t.version===r.stateVersion||s)return!1;return E.set(t.version,new Map(a)),Array.from(a).some((([n,o])=>{const r=m(e,t,n);return r.contents!==o.contents&&!("loading"===o.state&&"loading"!==r.state)}))}(e,t))))&&void 0!==n?n:[];return o}(e,n);if(r){const t=r;return v(e,u(t.latestLoadable),u(t.latestExecutionId)),u(t.latestLoadable)}return R(e,n)}const E=new Map;function N(e,t,n,o,r){const a=f(t);"loading"===e.state?(a.depValuesDiscoveredSoFarDuringAsyncWork=n,a.latestExecutionId=o,a.latestLoadable=e,a.stateVersion=null===r||void 0===r?void 0:r.version):(a.depValuesDiscoveredSoFarDuringAsyncWork=null,a.latestExecutionId=null,a.latestLoadable=null,a.stateVersion=null)}function k(e,t,n){const o=f(t);L(t,n)&&(o.depValuesDiscoveredSoFarDuringAsyncWork=e)}function V(e,t){L(e,t)&&c.delete(e)}function L(e,t){return t===f(e).latestExecutionId}function M(e){"loading"!==e.state&&C(e.contents)}function C(e){0}function D(e,n,o){e.atomValues.set(t,o),a.set(n,o)}function B(e,t){return a.get((n=>{"string"!==typeof n&&hn(!1);const o=zo(e,t,n);return null===o||void 0===o?void 0:o.contents}))}function U(e,n){return function(e){if(Yo.includes(t)){const e=`Recoil selector has circular dependencies: ${Yo.slice(Yo.indexOf(t)).join(" \u2192 ")}`;return Oo(new Error(e))}Yo.push(t);try{return e()}finally{Yo.pop()}}((()=>A(e,n)))}function O(e){e.atomValues.delete(t)}if(null!=r){return Wo({key:t,peek:B,get:U,set:(e,t,n)=>{let o=!1;const a=new Map;function i({key:n}){if(o)throw new Error("Recoil: Async selector sets are not currently supported.");const r=m(e,t,n);if(M(r),"hasValue"===r.state)return r.contents;throw"loading"===r.state?new qo(n):r.contents}function u(n,r){if(o)throw new Error("Recoil: Async selector sets are not currently supported.");const s="function"===typeof r?r(i(n)):r;Fo(e,t,n.key,s).forEach(((e,t)=>a.set(t,e)))}const c=r({set:u,get:i,reset:function(e){u(e,$o)}},n);if(void 0!==c)throw s(c)?new Error("Recoil: Async selector sets are not currently supported."):new Error("Recoil: selector set should be a void function.");return o=!0,a},init:h,invalidate:O,shouldDeleteConfigOnRelease:p,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:i})}return Wo({key:t,peek:B,get:U,init:h,invalidate:O,shouldDeleteConfigOnRelease:p,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:i})};const{loadableWithError:or,loadableWithPromise:rr,loadableWithValue:ar}=v,{DEFAULT_VALUE:ir,DefaultValue:sr,getConfigDeletionHandler:ur,registerNode:cr,setConfigDeletionHandler:lr}=j,{isRecoilValue:dr}=D,{markRecoilValueModified:fr,setRecoilValue:hr,setRecoilValueLoadable:pr}=we,{retainedByOptionWithDefault:vr}=it;function yr(e){const{key:t,persistence_UNSTABLE:n}=e,o=vr(e.retainedBy_UNSTABLE);let r,a=0,i=s(e.default)?rr(e.default.then((e=>{i=ar(e);return{__key:t,__value:e}})).catch((e=>{throw i=or(e),e}))):ar(e.default);const c=new Map;const l=cr({key:t,peek:function(e,n){var o,a,s;return null!==(o=null!==(a=n.atomValues.get(t))&&void 0!==a?a:null===(s=r)||void 0===s?void 0:s[1])&&void 0!==o?o:i},get:function(e,o){if(o.atomValues.has(t))return u(o.atomValues.get(t));if(o.nonvalidatedAtoms.has(t)){if(null!=r)return r;if(null==n)return T(`Tried to restore a persisted value for atom ${t} but it has no persistence settings.`),i;const e=o.nonvalidatedAtoms.get(t),a=n.validator(e,ir),s=a instanceof sr?i:ar(a);return r=s,r}return i},set:function(e,n,o){if(n.atomValues.has(t)){const e=u(n.atomValues.get(t));if("hasValue"===e.state&&o===e.contents)return new Map}else if(!n.nonvalidatedAtoms.has(t)&&o instanceof sr)return new Map;return r=void 0,(new Map).set(t,ar(o))},init:function(n,o,r){a++;const u=n.getState().knownAtoms.has(t);if(n.getState().knownAtoms.add(t),"loading"===i.state){const e=()=>{var e;(null!==(e=n.getState().nextTree)&&void 0!==e?e:n.getState().currentTree).atomValues.has(t)||fr(n,l)};i.contents.then(e).catch(e)}let d=ir,f=null;if(null!=e.effects_UNSTABLE&&!u){let o=!0;const a=e=>t=>{if(o){const n=d instanceof sr||s(d)?"hasValue"===i.state?i.contents:ir:d;d="function"===typeof t?t(n):t,s(d)&&(d=d.then((t=>(f={effect:e,value:t},t))))}else{if(s(t))throw new Error("Setting atoms to async values is not implemented.");"function"!==typeof t&&(f={effect:e,value:t}),hr(n,l,"function"===typeof t?n=>{const o=t(n);return f={effect:e,value:o},o}:t)}},u=e=>()=>a(e)(ir),p=e=>o=>{n.subscribeToTransactions((n=>{let{currentTree:r,previousTree:a}=n.getState();a||(y("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),a=r);const s=r.atomValues.get(t);if(null==s||"hasValue"===s.state){var u,c,l,d;const n=null!=s?s.contents:ir,r=null!==(u=a.atomValues.get(t))&&void 0!==u?u:i,h="hasValue"===r.state?r.contents:ir;(null===(c=f)||void 0===c?void 0:c.effect)!==e||(null===(l=f)||void 0===l?void 0:l.value)!==n?o(n,h):(null===(d=f)||void 0===d?void 0:d.effect)===e&&(f=null)}}),t)};for(const t of null!==(h=e.effects_UNSTABLE)&&void 0!==h?h:[]){var h;const e=t({node:l,trigger:r,setSelf:a(t),resetSelf:u(t),onSet:p(t)});null!=e&&c.set(n,e)}o=!1}if(!(d instanceof sr)){var p;const e=s(d)?rr(function(e,n){const o=n.then((n=>{var r,a;return(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&hr(e,l,n),{__key:t,__value:n}})).catch((n=>{var r,a;throw(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&pr(e,l,or(n)),n}));return o}(n,d)):ar(d);o.atomValues.set(t,e),null===(p=n.getState().nextTree)||void 0===p||p.atomValues.set(t,e)}return()=>{var e;a--,null===(e=c.get(n))||void 0===e||e(),c.delete(n),n.getState().knownAtoms.delete(t)}},invalidate:function(){r=void 0},shouldDeleteConfigOnRelease:function(){return void 0!==ur(t)&&a<=0},dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return l}function mr(e){const{default:t,...n}=e;return dr(t)?function(e){const t=mr({...e,default:ir,persistence_UNSTABLE:void 0===e.persistence_UNSTABLE?void 0:{...e.persistence_UNSTABLE,validator:t=>t instanceof sr?t:u(e.persistence_UNSTABLE).validator(t,ir)},effects_UNSTABLE:e.effects_UNSTABLE}),n=nr({key:`${e.key}__withFallback`,get:({get:n})=>{const o=n(t);return o instanceof sr?e.default:o},set:({set:e},n)=>e(t,n),dangerouslyAllowMutability:e.dangerouslyAllowMutability});return lr(n.key,ur(e.key)),n}({...n,default:t}):yr({...n,default:t})}var _r=mr;var gr=class{constructor(e){var t;R(this,"_map",void 0),R(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!==(t=null===e||void 0===e?void 0:e.mapKey)&&void 0!==t?t:e=>e}size(){return this._map.size}has(e){return this._map.has(this._keyMapper(e))}get(e){return this._map.get(this._keyMapper(e))}set(e,t){this._map.set(this._keyMapper(e),t)}delete(e){this._map.delete(this._keyMapper(e))}clear(){this._map.clear()}},Sr=Object.freeze({__proto__:null,MapCache:gr});const{LRUCache:wr}=Eo,{MapCache:br}=Sr,Tr={equality:"reference",eviction:"none",maxSize:1/0};var Rr=function({equality:e=Tr.equality,eviction:t=Tr.eviction,maxSize:n=Tr.maxSize}=Tr){return function(e,t,n){switch(e){case"none":return new br({mapKey:n});case"lru":return new wr({mapKey:n,maxSize:u(t)})}throw new Error(`Unrecognized eviction policy ${e}`)}(t,n,function(e){switch(e){case"reference":return e=>e;case"value":return e=>mo(e)}throw new Error(`Unrecognized equality policy ${e}`)}(e))};const{setConfigDeletionHandler:Ar}=j;var Er=function(e){var t;const n=Rr(null!==(t=e.cachePolicyForParams_UNSTABLE)&&void 0!==t?t:{equality:"value",eviction:"none"});return t=>{var o;const r=n.get(t);if(null!=r)return r;const{cachePolicyForParams_UNSTABLE:a,...i}=e,s=_r({...i,key:`${e.key}__${null!==(o=mo(t))&&void 0!==o?o:"void"}`,default:"function"===typeof e.default?e.default(t):e.default,retainedBy_UNSTABLE:"function"===typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE,effects_UNSTABLE:"function"===typeof e.effects_UNSTABLE?e.effects_UNSTABLE(t):e.effects_UNSTABLE});return n.set(t,s),Ar(s.key,(()=>{n.delete(t)})),s}};const{setConfigDeletionHandler:Nr}=j;let kr=0;var Vr=function(e){var t;const n=Rr(null!==(t=e.cachePolicyForParams_UNSTABLE)&&void 0!==t?t:{equality:"value",eviction:"none"});return t=>{var o;const r=n.get(t);if(null!=r)return r;const a=`${e.key}__selectorFamily/${null!==(o=mo(t,{allowFunctions:!0}))&&void 0!==o?o:"void"}/${kr++}`,i=n=>e.get(t)(n),s=e.cachePolicy_UNSTABLE,u="function"===typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE;let c;if(null!=e.set){const n=e.set;c=nr({key:a,get:i,set:(e,o)=>n(t)(e,o),cachePolicy_UNSTABLE:s,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u})}else c=nr({key:a,get:i,cachePolicy_UNSTABLE:s,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u});return n.set(t,c),Nr(c.key,(()=>{n.delete(t)})),c}};const Lr=Vr({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Mr=function(e){return Lr(e)};const Cr=Vr({key:"__error",get:e=>()=>{throw new Error(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Dr=function(e){return Cr(e)};var Br=function(e){return e};const{loadableWithError:Ur,loadableWithPromise:Or,loadableWithValue:xr}=v;function Ir(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[a,i]of t.entries())try{n[a]=e(i)}catch(r){o[a]=r}return[n,o]}function Pr(e){return null!=e&&!s(e)}function zr(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map((t=>e[t]))}function Fr(e){return null!=e&&"object"===typeof e&&e.hasOwnProperty("__value")?e.__value:e}function jr(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce(((e,n,o)=>({...e,[n]:t[o]})),{})}function $r(e,t,n){return jr(e,n.map(((e,n)=>null==e?xr(t[n]):s(e)?Or(e):Ur(e))))}var qr={waitForNone:Vr({key:"__waitForNone",get:e=>({get:t})=>{const n=zr(e),[o,r]=Ir(t,n);return $r(e,o,r)}}),waitForAny:Vr({key:"__waitForAny",get:e=>({get:t})=>{const n=zr(e),[o,r]=Ir(t,n);return r.some((e=>!s(e)))?$r(e,o,r):new Promise((t=>{for(const[n,a]of r.entries())s(a)&&a.then((a=>{o[n]=Fr(a),r[n]=void 0,t($r(e,o,r))})).catch((a=>{r[n]=a,t($r(e,o,r))}))}))}}),waitForAll:Vr({key:"__waitForAll",get:e=>({get:t})=>{const n=zr(e),[o,r]=Ir(t,n);if(r.every((e=>null==e)))return jr(e,o);const a=r.find(Pr);if(null!=a)throw a;return Promise.all(r).then((t=>{return jr(e,(n=o,r=t,r.map(((e,t)=>void 0===e?n[t]:e))).map(Fr));var n,r}))}}),waitForAllSettled:Vr({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=zr(e),[o,r]=Ir(t,n);return r.every((e=>!s(e)))?$r(e,o,r):Promise.all(r.map(((e,t)=>s(e)?e.then((e=>{o[t]=Fr(e),r[t]=void 0})).catch((e=>{o[t]=void 0,r[t]=e})):null))).then((()=>$r(e,o,r)))}}),noWait:Vr({key:"__noWait",get:e=>({get:t})=>{try{return xr(t(e))}catch(n){return s(n)?Or(n):Ur(n)}}})};const{batchUpdates:Gr,setBatcher:Wr}=Ve,{DefaultValue:Hr}=j,{RecoilRoot:Kr}=ln,{isRecoilValue:Zr}=D,{retentionZone:Jr}=q,{freshSnapshot:Xr}=Bt,{useGotoRecoilSnapshot:Qr,useRecoilCallback:Yr,useRecoilSnapshot:ea,useRecoilState:ta,useRecoilStateLoadable:na,useRecoilTransactionObserver:oa,useRecoilValue:ra,useRecoilValueLoadable:aa,useResetRecoilState:ia,useRetain:sa,useSetRecoilState:ua,useSetUnvalidatedAtomValues:ca,useTransactionObservation_DEPRECATED:la}=ao,{noWait:da,waitForAll:fa,waitForAllSettled:ha,waitForAny:pa,waitForNone:va}=qr;var ya={DefaultValue:Hr,RecoilRoot:Kr,useRecoilBridgeAcrossReactRoots_UNSTABLE:ho,atom:_r,selector:nr,retentionZone:Jr,atomFamily:Er,selectorFamily:Vr,constSelector:Mr,errorSelector:Dr,readOnlySelector:Br,useRecoilValue:ra,useRecoilValueLoadable:aa,useRecoilState:ta,useRecoilStateLoadable:na,useSetRecoilState:ua,useResetRecoilState:ia,useGetRecoilValueInfo_UNSTABLE:uo,useRetain:sa,useRecoilCallback:Yr,useGotoRecoilSnapshot:Qr,useRecoilSnapshot:ea,useRecoilTransactionObserver_UNSTABLE:oa,useTransactionObservation_UNSTABLE:la,useSetUnvalidatedAtomValues_UNSTABLE:ca,noWait:da,waitForNone:va,waitForAny:pa,waitForAll:fa,waitForAllSettled:ha,isRecoilValue:Zr,batchUpdates:Gr,setBatcher:Wr,snapshot_UNSTABLE:Xr},ma=ya.RecoilRoot;function _a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function ga(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?_a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):_a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var Sa=function(e){var t=e.Component,n=e.pageProps;return(0,r.jsx)(ma,{children:(0,r.jsx)(t,ga({},n))})}},1780:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/_app",function(){return n(9316)}])},2702:function(){}},function(e){var t=function(t){return e(e.s=t)};e.O(0,[774,179],(function(){return t(1780),t(4651)}));var n=e.O();_N_E=n}]);